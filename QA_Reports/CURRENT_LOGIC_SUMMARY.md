# 現在のコード生成ロジック詳細 (v1.3)

現在実装されている **「1拍1コード判定 (Beat-Quantized Generation)」** の具体的なアルゴリズム仕様です。
このロジックをベースに、さらに和声区間を統合（マージ）する処理を検討するための資料となります。

## 1. 処理フロー概略

プログラムは以下の順序で「ベース1音ごと」から「拍ごとの和声」へと情報を変換しています。

1.  **Beat Grouping**: 全ノートを「拍 (Beat)」の箱に振り分ける。
2.  **Dominant Selection**: 各拍の中で「主役」となるベース音を1つ決める。
3.  **Chord Determination**: 「主役」の音から、その拍のコードを決定する。
4.  **Style Application**: 決定されたコードを使って、伴奏パターン（Pad/Arp）を生成する。

---

## 2. アルゴリズム詳細

### A. Beat Grouping (拍ごとのグループ化/グルーピング)
`pretty_midi.get_beats()` で取得したグリッド（例: 0.0s, 0.5s, 1.0s...）に基づき、時間を区切ります。

*   **処理単位**: 1拍（4分音符区間）
*   **振り分け条件**:
    *   ノートの `Note On` タイミングが `[BeatStart, BeatEnd)` の区間に含まれていれば、その拍に所属させます。
    *   *※現状、小節をまたいで伸びている音（タイ）は「発音開始した拍」にのみ所属します。*

### B. Dominant Selection (ドミナント・ルート選定)
「1拍の中にベース音が4つある（例：16分音符 4発）」場合、どれをルートとして採用するかを以下の優先順位で決定します。

*   **判定基準**:
    1.  **音価 (Duration)**: 最も長い音符を最優先。
    2.  **ベロシティ (Velocity)**: 長さが同じなら、最も強く弾かれた音を優先。
    3.  **出現順**: それも同じなら、拍の最初にある音を優先。

> **例**: 1拍の中に `C(16分)`, `E(16分)`, `G(8分)`, がある場合
> -> `G` が一番長いので、この拍は「Gルート」として判定されます（Gコードが生成される）。

### C. Chord Determination (コード決定)
選ばれた「ドミナント・ルート」に対して、調（Key）設定に基づいたコードを割り当てます。

*   **入力**: ドミナント音のピッチ（オクターブ正規化済み）
*   **ロジック**: `DiatonicTriadStrategy`
    *   選択されたキー（例：C Major）のダイアトニックコード（III なら Em）を生成。

### D. Style Application (スタイル適用)
決定した「拍のコード」を、スタイルごとのルールでMIDIノートに変換します。

| スタイル | 挙動 |
| :--- | :--- |
| **Pad (白玉)** | 拍の開始(`BeatStart`)から終了(`BeatEnd`)まで伸びる、全音符的なコードを1つ生成します。音量はずっと一定です。ベースが細かく動いてもPadは動きません。 |
| **Rhythm / Arp** | **ベースの発音タイミング（リズム）** を使い回しますが、**音程（ピッチ）** は「拍のコード」に強制変換します。<br>例：ベースが `C - E - G - E` と動いても、判定が `C` なら、伴奏は `Cメジャー` の和音で4回刻みます。 |

---

## 3. 今後の拡張ポイント（マージ処理の提案箇所）

現状は「1拍単位」で必ず切れますが、以下のような箇所に「コードのマージ処理」を挟む余地があります。

*   **Pre-Generation Merge**:
    *   手順「B」と「C」の間で実施。
    *   「拍1のルート」と「拍2のルート」が同じ（あるいは機能的に類似）なら、**2拍分の長い区間** として統合する。
    *   *効果*: Padが拍ごとに `ダッ、ダッ` と途切れず、 `ダーー` と滑らかに繋がるようになります。

具体的なマージ条件（例：ルートが同じなら繋ぐ、コード機能が同じなら繋ぐ、など）をご指示いただければ実装可能です。
